string connection ?= null
uuid processVersionId ?= null
uuid processActionId ?= null

definition = nabu.frameworks.process.providers.action.service.utils.getProcessDefinition(connectionId: connection, processVersionId: processVersionId)/definition

if (definition == null)
	throw("Definition not found")
	
findNext = lambda
	actionId ?= null
	
	# add it to the list
	#@persist
	#alreadyChecked = series.resolve(merge(alreadyChecked, actionId))
	alreadyChecked ?= series(actionId)
	
	# get all the outgoing relations for the given action
	outgoingRelations = definition/actionRelations[actionId == /actionId && (relationType == "flow" || relationType == "flow-start" || relationType == "flow-failed")]
	
	if (outgoingRelations != null)
		@return
		impactedActionIds = series.resolve(merge(impactedActionIds, outgoingRelations/targetActionId))
		
		newAlreadyChecked = series.resolve(merge(alreadyChecked, outgoingRelations/targetActionId))
		
		# resets AFTER the reset we are triggering should be reset themselves but we DONT want to iteratively follow where that reset leads because (by its very nature) it will likely loop back creating a high likelihood of resetting something you don't want.
		for (single : outgoingRelations[actionType != "reset"]/targetActionId)
			if (single !? alreadyChecked)
				impactedActionIds = series.resolve(merge(impactedActionIds, findNext(single, newAlreadyChecked)))
	
@return
uuid [] impactedActionIds = findNext(processActionId)